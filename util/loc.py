#
# Copyright 2018 justworx
# This file is part of the trix project, distributed under
# the terms of the GNU Affero General Public License.
#


from .. import *
import locale


class BaseLocale(object):
	"""
	Base for SysLoc subclass and, potentially, future variants.
	"""
	
	def __init__(self, loc_data):
		"""
		Pass a dict `loc_data` as generated by trix.app.cline.loc or
		the assets locale_json file.
		
		All items from loc_data are set as member variables.
		"""
		# add each loc_data value as an object member variable
		self.__locdata = loc_data
		for v in loc_data:
			self.__dict__[v] = loc_data[v]
	
	def __getitem__(self, key):
		"""Return locale format by name `key`."""
		return self.__locdata[key]
	
	def keys(self):
		"""Return dict of locale data."""
		return list(self.__locdata.keys())
	
	def locdata(self):
		"""Return dict of locale data."""
		return self.__locdata
	
	def display(self):
		"""Display JSON representation of locale data."""
		trix.display(self.__locdata)





class Locale(BaseLocale):
	"""
	The `Locale` class provides access to data from multiple locale 
	files by generating data for any given locale in a separate process.
	
	"""
	
	AssetPath = '%s/assets/locale_json.tar.gz' % DEF_CACHE
	
	def __init__(self, loc_str):
		"""
		Pass a locale description string. Returns a dict containing
		locale format data.
		
		The `loc_str` argument must be a string in the following format:
		 * langcode_country.encoding
		 * Eg., "en_US.utf8"
		
		"""
		
		try:
			#
			# This will fail on first call, so will be handled below. On
			# subsequent calls, it will succeed here.
			# 
			BaseLocale.__init__(self, Locale.__qdict(loc_str))
		except:
			# here's why it will succeed on subsequent calls...
			try:
				# try to use asset locale data if possible...
				Locale.__qdict = Locale.query_asset_dict
			except:
				# otherwise, query the local system for locale data
				Locale.__qdict = Locale.query_locale_dict
			
			# here's the initialization for the first call
			
			BaseLocale.__init__(self, Locale.__qdict(loc_str))
	
	
	@classmethod
	def list(cls, pattern=None):
		"""
		Return a proplist containing all locales that match `pattern`.
		The default `pattern` is '*.utf8*, which returns the locale 
		signature for a complete set of language_country locales (with
		the exception of Gallcian Spain, which I've not yet been able to
		successfully download).
		
		```python3
		from trix import *
		trix.loc().list.table(w=6)
		trix.loc().list("en_*").table(w=6)
		trix.loc().list("*_IN*").table(w=6)
		
		```
		"""
		pattern = pattern or '*.utf8*'  # default search: "*.utf8*"
		p = trix.path('%s/assets/locale_json.tar.gz'%DEF_CACHE) #loc path
		a = p.wrapper(encoding='utf_8') # open archive
		return a.names.fnmatch(pattern)
		
	
	@classmethod
	def validate_locstr(self, loc_str):
		"""
		Converts a reasonably valid loc_str to the format in which locale 
		members are stored in the asset file, changing case and encoding
		values to match exactly. Eg., "En_Us.Utf-8" to "en_US.utf8", etc.
		
		>>> Locale.validate_locstr("AA_er.UTF-8@SAAHO")
    'aa_ER.utf8@saaho'

		"""
		s = trix.scan(loc_str)
		ll = s.splits("_.@")
		ll[0]=ll[0].lower()
		ll[1]=ll[1].upper()
		
		ln = len(ll)
		if ln<3:
			return "%s_%s" % ll
		
		#
		# If an encoding is included, make sure it matches member naming
		# conventions in the locale scheme.
		#
		eh = "util.enchelp.EncodingHelper"
		e = trix.ncreate(eh, encoding=ll[2]).encoding
		if e == 'utf_8':
			ll[2] = 'utf8'
		else:
			ll[2] = ll[2].lower()
		
		# if we get this far, there may be a remainder...
		rem = s.remainder()
		if rem:
			ll.append(rem.lower())
			return  "%s_%s.%s@%s" % tuple(ll)
		
		# otherwise, it's just the three basic elements
		else:
			return "%s_%s.%s" % tuple(ll)
			
		
		
	@classmethod
	def query_asset_dict(cls, loc_str):
		"""Query locale dict from assets."""
		loc_str = cls.validate_locstr(loc_str)
		j = trix.path(cls.AssetPath).wrapper().read(loc_str)
		return trix.jparse(j)
	
	@classmethod
	def query_locale_dict(cls, loc_str):
		"""Query locale dict from system locale data."""
		cline = "%s -m %s loc -c %s" % (
				sys.executable, trix.innerfpath(), loc_str
			)
		cx = trix.callx(cline)
		js = cx.reader().read()
		return trix.jparse(js)


